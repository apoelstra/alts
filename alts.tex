% Default course lecture note template by asp 
\documentclass[letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage[top=3cm, bottom=3cm, left=3.85cm, right=3.85cm]{geometry}
\usepackage[onehalfspacing]{setspace}
\usepackage{amsmath,amssymb,wasysym,amsthm}
\usepackage{graphicx}
\usepackage{mathptmx}
\usepackage{hyperref}
\usepackage[usenames,dvipsnames]{color}

\title{A Treatise on Altcoins}
\author{Andrew Poelstra}
\date{Last update: 8 May 2014}

\begin{document}

\maketitle

\section{Preamble}

Why am I writing this document? Because when I first entered the
world of cryptography, there were certain common-sense maxims which
were passed around such as \emph{to design a cryptosystem, you must
first think like a cryptanalyst} or \emph{anybody can make a cryptosystem
which they themselves cannot break}. For most people, these maxims
could be summarized simply as \emph{don't roll your own crypto}. Anyone
who flouted this golden rule, without decades of schooling and experience,
was rightly dismissed as a crank or a troll.

Of course, there were a few people who didn't subscribe, and they would
spend years repeating their half-baked ideas, conspiracy theories, factoring
algorithms and NSA-proof cryptography on \texttt{sci.crypt}. These people
were often ridiculed but just as often sincerely advised to seek mental help.
I hope for their sake that some of them have since done so. At no point were
their ideas taken seriously, used, or, god forbid, invested in.

However, shortly after the turn of the 21st century, Adam Back discovered
a novel type of cryptography called \emph{proof-of-work} which enabled a
\emph{distributed consensus}
cryptosystem. This cryptosystem was used in 2009 by Satoshi Nakomoto to
develop the first decentralized \emph{cryptocurrency} --- Bitcoin --- which
was also the first experimental cryptosystem to see billions of dollars
poured into it by people who had no understanding of its mechanisms.

By that time, the benefits of doing cryptography in the open had long
since been made clear, so Bitcoin's reference implementation was fully
open-sourced. This allowed anybody to see the code, and anybody to fork
it to develop their own cryptosystems. Of course, ``developing your own
cryptosystem'' is the purview of only cranks and researchers, so it was
reasonably assumed that none of these ``altcoins'', as they were called,
could ever be plausibly presented for public use.

Boy, were we ever wrong on that one.

The purpose of this document is twofold:
\begin{enumerate}
\item If you are a member of the public interested in cryptocurrencies,
this document discusses what cryptocurrencies, and cryptosystems in general,
are. It discusses the miracles and dangers of modern cryptography, and
the serious risks associated with cryptosystem-tweaking by unqualified
(and even qualified!) people.

Since Bitcoin has introduced direct monetary value to new cryptosystems,
it is not only cranks doing stupid things with it, but also liars and
thieves. This document also discusses that side of altcoin development.
\item If you are, or are planning to, develop and release an ``altcoin''
to the public, this document reminds you that you are playing with fire.
This sort of behavior was cute on \texttt{sci.crypt}, a community populated
mainly by cryptographic experts where there was no risk that your charlatanism
would be mistaken for anything legitimate, and where there was no ability to
store value in your scheme anyway.

The Bitcoin community differs in both those respects. Your crankery is
not cute. You are not a cryptographer, and yet are releasing a homebrew
cryptosystem, misrepresenting your own qualifications, and encouraging
others to store value in your creation. These actions are incompetent,
dishonest and reprehensibly dangerous.

If somehow you are doing this through honest cluelessness, I dream that
you'll read this article and realize the error of your ways.
\end{enumerate}

\section{What are cryptosystems?}

Modern cryptography, as a field, studies the ability and techniques of
controlling information flows independently of containing data flow.
For example, using public-key cryptography it is possible to broadcast
data such that the information contained is only accessible to a single
person.

Until the advent of modern cryptography, philosophical questions, such
as ``where'' the information actually is, were considered just that:
philosophical questions. Intuitively, if you write some information
down, it's right there on the page in front of you, available to anybody
who can read it. In light of this intuition, it is something of a miracle
that modern cryptography should be able to exist at all. And given that
we evolved this intuition which has served us perfectly well until very
recently, it should be expected that modern cryptography is an extremely
subtle and perilous practice. Indeed, this is the case.

This cryptographic idea of ``separating information flow from data flow''
can be put on good mathematical footing, and much progress has been made
in this direction \footnote{See, for example, Shafi Goldwasser and Silvio
Micali, Probabilistic Encryption, Special issue of Journal of Computer and
Systems Sciences, Vol. 28, No. 2, pages 270-299, April 1984. Available online.},
though there are still many fundamental open problems\footnote{For example,
functions such as \texttt{SHA256d} which are easy to calculate but hard to
invert are called \emph{one-way functions}. However, \texttt{SHA256d} is
merely assumed to be one-way, but no proof has been found --- in fact, no
proof has been found that \emph{any} one-way functions exist!}. By reading
papers in this field, one gets a sense for the difficulty of making
concrete statements about such subtle concepts, and for the precision
with which one's assumptions must be made.

A \emph{cryptosystem} is a collection of algorithms which work together
to achieve some cryptographic goal. A typical cryptosystem consists of
three algorithms: key generation, encryption, and decryption. Cryptosystems
are typically published alongside security proofs which reduce the problem
of ``breaking'' the cryptosystem (e.g. learning some bits of the input to
the encryption algorithm from its output) to some ``hard'' mathematical
problem such as finding a discrete logarithm of an elliptic curve group
element. These proofs are intricate, subtle, and their relation to reality
is a subject of intense controversy\footnote{Alexander Dent, Fundamental
Problems in Provable Security and Cryptography, retrieved from the IACR
preprint archive, 2006. \url{http://eprint.iacr.org/2006/278.pdf}}. An
important thing to note is that these proofs also consider the cryptosystem
as a whole: change one algorithm even slightly, and the security proof of
another algorithm could be completely invalidated.

Nonetheless, we interact daily with many cryptosystems, most of which we
do not even think about. We assume the security of these systems partially
because there is legal recourse if they are broken, partially because this
is the way that we've always done things, and it seems like security breaches
are reasonably uncommon, and partially because we assume that very smart people
designed these systems to be hard to break. After all, there's a lot of money
riding on them.

Of course, even if these things are true about the cryptosystems we use to
check our email, do our banking, buy groceries and store private data, there
is no reason to believe in them for novel cryptosystems designed by anonymous
people to do unprecedented things. This is largely responsible for the ``crank''
label assigned to so many pointless projects on \texttt{sci.crypt}.

\section{What are cryptocurrencies?}

A \emph{cryptocurrency} is a cryptosystem designed to facilitate the transfer
of value, by transferring scarce goods defined within the system itself. The
prototypical example is Bitcoin, which transfers signing authority and maintains
a global ledger of value associated to this authority. The primary innovation
of Bitcoin was the creation of this ledger, which is updated and verified in
a completely decentralized fashion, with all parties agreeing on the atomicity
of transactions and their ordering in time.

Out of necessity, cryptocurrencies are enormous cryptosystems and contain many
smaller cryptosystems as components. This makes them fearsomely complex, and
their security correspondingly difficult to verify, but the fact that Bitcoin
has held up for over five years gives evidence that this complexity can be
managed.

Adding to the complexity of the cryptosystem itself is the fact that exchanging
value necessarily involves economic considerations. Therefore cryptocurrencies
must be analyzed not only for computational soundness and security, but also
for \emph{economic} soundness and security. That is, is the cryptocurrency
designed so that the incentives are aligned with the goal of security the system,
and \emph{not} with the goal of undermining it?

To illustrate the complexity of Bitcoin, and to give an overview of its
workings (which we will cover in more detail in Sections \ref{txes} and
\ref{consensus}), we have broken the cryptosystem
down into its constituent algorithms. The cryptosystem in its entirety is
run by every validating ``full'' node on the network. We assume the existence
of a communications network by which nodes are able to exchange data. (In
practice, Bitcoin nodes use a peer-to-peer network, and communicate by the
``Bitcoin protocol''.)

Such a breaking-down is necessarily subjective and gives an incomplete view
of the system\footnote{Robert Pirsig, Zen and the Art of Motorcycle Maintenance,
1974}, but is didactically necessary.
It is important to emphasize that this is \emph{one cryptosystem} and the
security (economic and computational) of every component is tied to that
of every other. Therefore, anyone hoping to change a single component must
understand the entire system and have the technical background to analyse
and implement the change.

We now give an overview of each component of Bitcoin, leaving detailed
cryptographic discussion to future sections.

\paragraph{Setup.} When a Bitcoin node is first started it creates two
data structures, a weighted hash tree called the \emph{blockchain} and
a database called the \emph{utxo set}, both of which are initially empty.
Elements of the blockchain are called \emph{blocks}; elements of the
utxo set are called \emph{utxos} or \emph{unspent transaction outputs}.
The motivation for these terms will become clear.

It then contacts another node to request the highest-weighted path in
its blockchain. For each block in this path (which must start with the
so-called \emph{genesis block} whose hash is hardcoded into the node),
the node runs its Block Verification algorithm, which updates its
chainstate.

\paragraph{Relay.} Each time a node sees a transaction on the network,
it runs its Transaction Verification algorithm. If this passes, the
node passes the transaction to each of its peers (after a small delay,
to prevent flooding attacks).

Similarly, each time a node sees a block on the network, it runs its
Block Verification algorithm. If this passes, and if the new block is
part of the highest-weight blockchain path, the node passes the block
to each of its peers.

\paragraph{Signature (Script) Evaluation.} Since Bitcoin transactions
transfer value, a basic requirement for a transaction to be valid is
that the previous owner of the coins has signed off on the transfer.
So-called \emph{digital signatures} are well-studied cryptographic
primitives, and typically consist of a cryptographic proof that the
holder of the private half of some keypair has manipulated a message
in some distinctive and easily-verified way.

Since Bitcoin transcations are financial transactions, which are often
executions of more complicated contracts than ``the sole owner of some
coin signed off on this spend''. Therefore Bitcoin's signature system
contains an expressive stack-based scripting language. Often Bitcoin's
script is assessed as though it were a programming language; however,
its cryptographic function is to be a digital signature scheme, and
therefore its most essential attributes are that script-based signatures
are publically verifiable and existentially unforgeable\footnote{Actually,
Bitcoin's script is expressible enough to produce signatures which can
be forged with varying degrees of ease; an extreme example would be a
transactions whose outputs can be spent by anybody at all. On the other
hand, pay-to-address transactions should have outputs which are unspendable
except by the target address's owner.  So ``existential unforgeability''
is not quite the correct security requirement for Bitcoin signatures.
There is something more subtle here.}

This language has the capacity to push and pop data, branch on simple
conditions, and also execute some traditional cryptographic primitives.
Simple Bitcoin transactions may be little more than thin wrappers around
these primitives; for example, traditional ``pay-to-address'' transactions
check (a) that a transaction is signed by a traditional ECDSA signature,
and (b) that the correct address can be derived from signature's key.

\paragraph{Transaction Verification.} At its heart, a Bitcoin transaction
is composed of two main parts: the inputs and the outputs. As the inputs
refer to the outputs of other transactions, we cover them first.

Both inputs and outputs are constructed from \emph{scripts}, which are
instructions in a Bitcoin-specific stack-based programming language.
This language is very small and does not support looping, so that it
can be consistently implemented and easily audited.
 
Outputs are fairly simple: they consist of (a) a value, which is the
number of Bitcoins the output represents, and (b) a script which reads
values from the stack then either passes or fails. A typical script
might expect the stack to contain a digital signature, for example.
All that is needed to validate outputs is that their scripts use the
defined script opcodes.

Inputs are more intricate: they consist of (a) a reference to an output
of an existing transaction and (b) a script which places values on the
stack. To validate an input, it is first checked that the referenced
transaction output has not been spent, \emph{i.e.} it appears in the
utxo set. Then that output's script is concatenated to the input's
script, and the concatenated script is run using the Script Evaluation
algorithm. If the algorithm accepts, the transaction is valid.

Further, the total value of outputs must be greater than or equal to
the total value of the inputs (input values are defined as the values
of their referenced outputs). If the input total is strictly greater
than the output total, the difference is called a \emph{transaction fee}
and is recaptured by the network.

There is one exception to this last rule for so-called \emph{coinbase
transactions}. These are special transactions which occur once in each
block and may be created with no inputs at all. They are the mechanism
by which new Bitcoins are brought into circulation. The total output
size must be less than or equal to the \emph{block reward} plus the
total network fees for all other transactions in the block.

\paragraph{Transaction Generation.} To create a transaction, a node
selects outputs from its utxo set which it has the capacity to spend
(for example, outputs whose scripts expect a digital signature, and
the node is in possession of the requisite key.) It chooses enough
outputs so that their total value is greater than or equal to the
amount desired to spend.

It then creates new outputs which the transaction's recipient has
the capacity to spend (typically this requires contacting the recipient
through another channel, \emph{e.g.} to obtain the hash of a public
key for which the recipient has the corresponding private key), and
sets their values so that the total is equal to the amount desired
to spend.

Any discrepancy between the total input value and total output value
is considered as a network fee. To reduce this, the node may add an
additional ``change'' output, which it has the capacity to spend itself.

\paragraph{Block Verification.} To verify a block, the Bitcoin node
first checks that it is formed correctly and that the correct hash of
its contents is in its header. It also checks that the hash of the
block is within a small range --- the exact range is calculated by
observing the timestamps of the block's ancestors and attempting to
adjust so that future blocks will be created roughly every ten minutes.
See the Block Generation algorithm for more details about this. 

It then runs the Transaction Verification algorithm on every transaction
in the block, and if any of them fail, the block is invalid.

It is crucial to the Bitcoin cryptosystem that all nodes agree on the
result of the Block Verification algorithm --- and by extension, that
all nodes agree on Transaction Verification, Script Evaluation, and
Difficulty Calculation. That is, these algorithms are \emph{consensus
algorithms}. More about this will be discussed in Section \ref{consensus}.

The block is weighted in the blockchain according to its difficulty.

\paragraph{Block Generation.} Unlike the previous algorithms, Block
Generation is not done by most Bitcoin nodes, since it is designed to
be very computationally expensive. Today it requires special-purpose
hardware to be feasible.

To create a block, a node assembles a list of transactions, which are
obtained through the Bitcoin network and all pass the Transaction
Verification algorithm. The node also creates a coinbase transaction,
which has no inputs and whose outputs can be spent by the node itself.

These transactions are hashed up, and the resulting hash is put
alongside a timestamp and nonce in the \emph{block header}. In order
that the new block pass the Block Verification algorithm, its hash must
fall into a small range defined by the Difficulty Calculation algorithm.
To accomplish this, the block is hashed \emph{ad nauseum} for different
values of the nonce until a hash is found which falls into the required
range. This computation is called a \emph{proof of work}, and Bitcoin's
security depends on it satisfying several subtle mathematical properties,
which will be discussed in Section \ref{consensus}.

\paragraph{Difficulty Calculation.}

There are two reasons that Bitcoin blocks are accompanied by a proof-of-work.
One is to create an opportunity cost for extending the blockchain, forcing
would-be attackers to commit to a single branch of the chain. The other is
to slow the pace of blockchain extensions so that the entire network can be
made aware of each block before it is extended. The proof-of-work also provides
a natural way to weight the each block, so that for every path in the blockchain
one can compute the ``total work''. The higher the total work of a path, the more
participants are (statistically) required to participate to create it, and
therefore ``highest total work'' is a proxy both for ``known to the most
people''\footnote{Pieter Wuille pointed out to me that since the hashpower of
the Bitcoin network has increased by many orders of magnitudes, it is only a
high \emph{recent} total work that can be used as a proxy for visibility. For
example, a modern ASIC miner could easily outdo the total work of the first
200k Bitcoin blocks without publishing anything. On the other hand, the timescale
on which hashpower changes by orders of magnitude is much larger than the timescale
at which we assume the network is synchronous, so by the time an attacker is able
to individually out-work a path, that path will have been extended beyond his reach
and the extension will already by globally visible. Therefore by the time a
difference between the visibility implied by total work and that implied by recent
total work develops, that difference is long since irrelevant.}
and ``hardest to forge''. For these reasons, Bitcoin nodes are able to
achieve a distributed consensus on the ``real'' blockchain by considering
reality to be synonymous with greatest total work\footnote{This exposition of
the function of proof-of-work is far from being a scientific consensus. What
is agreed on is that there are mathematical proofs that cryptographically-enforced
distributed consensus is impossible, and that Bitcoin evades these impossibility
results by introducing economic concepts such as opportunity costs. It is far
from clear what the correct formalization of the security (including forces
against censorship and centralization) properties required of a proof-of-work
are, and whether Bitcoin's proof-of-work achieves those goals. For more information
see Andrew Miller's recent work.}.

(Since blockchain paths intrinsically order their contained blocks, consensus on
the blockchain immediately gives rise to consensus on transaction ordering,
which is what Bitcoin actually needs to resolve double-spend incidents consistently.)

To keep the blockrate low enough that the network has time to achieve consensus,
while high enough to facilitate transactions at a useful pace, Bitcoin attempts
to produce blocks on average every ten minutes. It accomplishes this by a negative
feedback loop between the blocktimes (as encoded in the blocks themselves, which
are manipulable by dishonest miners) and the block difficulty.

As described in Section \ref{consensus}, Bitcoin's proof-of-work scheme is that
of Adam Back's HashCash, and works by requiring the \texttt{SHA256d } hash of
valid blocks' headers to lie within a small range. The difficulty parameter is
inversely proportional to the size of this range, and assuming that \texttt{SHA256d}
values are uniformly random\footnote{This is the so-called \emph{random-oracle
assumption} on the hash function, which is that a hash function can be modeled
by a mathematically random function. This is physically impossible since the
Komolgorov complexity of a true random function would be infinite while that
of \texttt{SHA256d} is comparatively very small. But it's an empirical fact
that nobody has found a computationally feasible to skew the \texttt{SHA256d}'s
output distribution away from uniform.}, the size of this range is directly
proportional to the probability that any given block will be valid. Miners
churn through the space of possible block headers by incrementing a nonce,
so that between any two valid blocks, miners may have collectively churned
through many quadrillion invalid ones.

The short version of the above: if blocks' timestamps are too close together
then the difficulty increases, meaning that the range of valid hashes shrinks.
Conversely, if blocks are too far apart the range grows. The result is a
negative feedback loop designed to cause blocks to appear every ten minutes
on average.

\section{Cryptography is hard.}

In this section we will step away from the specifics of cryptocurrencies and
look at cryptography in general. Modern cryptography is an exciting but
extremely subtle field. Theoretical cryptography sits at the intersection
of computing science, algebra, statistics, physics and philosophy, while
applied cryptography involves all of the above in addition to software
engineering, electrical engineering, social science and economics\footnote{Not
to mention the revolutionary historical and political implications of the
\emph{use} of cryptography; there is much to be said about these aspects of
Bitcoin, which we will try to avoid for the purposes of this text.}

[tell stories about ``obviously'' amateur cryptosystems, e.g. altoz, as well
as non-obviously amateur ones, e.g. etherium's encrypt-against-key system,
as well as professional ones, e.g. ECDSA's ridiculous $k$-reuse problem]
[tell stories about serious cryptosystems broken in weird ways, eg TLS 1.0 side-channel attack]

\section{Cryptography of Bitcoin 1: transactions and signatures. \label{txes}}

Bitcoin transactions conceptually work as follows: to spend a Bitcoin, you
digitally sign a message that contains (a) the amount to be spent, and (b)
a public key of the recipient. Then when the recipient wants to spend money,
he has to provide a reference to the transaction that gave it to him, and
sign a new message with the key from that transaction.

As discussed above, the actual implementation is more involved in order to
support splitting up balances, controlling what data is signed, etc. And
because financial contracts are often more complex than ``the money of
party $X$ now belongs to party $Y$'', Bitcoin's signature algorithm actually
contains a simple scripting language

[explain transactions and signatures, CHECKSIG etc]
[explore dangerous/bad ideas]
\begin{itemize}
\item Turing completeness, script expressiveness
\item Extrospection
\end{itemize}

\section{Cryptography of Bitcoin 2: distributed consensus.\label{consensus}}

More than anything else, Bitcoin is a distributed consensus system. This
means that it is composed of many disparate systems, each of which may
leave or join at any time, who need to come to consensus on the chainstate.
The way that Bitcoin accomplishes this is by a hash-based proof of
work\footnote{Bitcoin's proof-of-work was invented by Adam Back as part
of Hashcash, a precursor to Bitcoin. See Adam Back, \emph{Hashcash - A Denial
of Service Counter-Measure}, technical report, August 2002.}. It is not
clear whether this mechanism is a viable way to achieve distributed consensus
in a decentralized way --- indeed, even the most na\"ive analysis involves
economic incentive analysis, hardly a standard component of cryptographic
proof --- but Bitcoin has been operating in a somewhat decentralized
fashion for over five years, and this gives us hope.

Having said that, distributed consensus systems have new and catastrophic
failure modes which do not exist in ordinary systems. Even the simple-minded
changes made to Bitcoin by typical alt-currencies have been enough to
trigger these failure modes.

[explain distributed consensus works, risk of forks, incentive issues, etc]
[explore dangerous/bad ideas]
\begin{itemize}
\item Dependence on architecture (type width, floating point)
\item Speed and clamping of difficulty changes
\item Verification versus search speed for PoW
\item PoW with different hardware requirements
\item Block frequency and size
\item Proof of stake
\item Update management (dogecoin's unplanned fork, lack of broadcast keys, etc)
\end{itemize}

\section{Where do I go from here?}

I hope this document has provided some perspective on the intellectual
magnitude of tackling cryptographic projects. Even experts shy away from
developing new cryptosystems, preferring to use tried and true cryptographic
primitives which have withstood the test of time and been analysed in depth
by thousands of people. However, there are many open problems and exciting
research directions in cryptography and the field is remarkably accessible
to those willing to invest a few years into learning its history.

As a start, several active and famous cryptographers maintains blogs devoted
to presenting cryptographic ideas in accessible ways. Of particular interest
are those of Matthew Green and Bruce Schneier. Also current academic research
is typically posted to the preprint archive at \texttt{eprint.iacr.org}. It
is helpful to skim the abstracts periodically, both to find interesting papers
and to get an idea of current trends in cryptographic research.

For an historical account from ancient times through World War II, read
David Kahn's tome \emph{The Codebreakers}. This is a very long text, but an
enjoyable and engaging read.

Regarding modern cryptography, many classic papers are available online. An
incomplete and unordered list of essential reading is:
\begin{itemize}
\item \emph{Probabilistic Encryption}, Goldwasser and Micali, 1984.
\item \emph{A Public-Key Cryptosystem and a Signature Scheme Based on Discrete Logarithms}, ElGamal, 1985.
\item \emph{The Decision Diffieâ€“Hellman Problem}, Boneh, 1998.
\item \emph{How to Prove Yourself: Practical Solutions to Identification and Signature Problems}, Fiat and Shamir, 1986.
\end{itemize}
It is also worthwhile to read the Wikipedia article on zero-knowledge proofs,
which has plenty of citations, but is more clearly written than any of them \smiley.

\section{Conclusion.}

\end{document}



